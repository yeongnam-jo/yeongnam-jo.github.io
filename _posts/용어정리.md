# [용어 정리]

1. default

   - 명시하지 않으면 자동으로 실행되는 것

2. ASCII / UNI 

   - ASCII : 2^8
   - UNI: 2^16
     - 의미: UNIVERSAL(전 세계에서 쓰겠다)
     - 종류
       - 가변길이: 영어는 1BYTE로 인식
         -  lengthb('abcd') : 4 (BYTE)
         -  lengthb('대한민국') : 12(BYTE) 
       - 고정길이: 영어도 2BYTE 또는 3BYTE로 인식
   - 예시 
     - 'A': 1 BYTE (영어 한 글자는 1바이트)
     - '가': 2~3 BYTE (한글 한 글자는 2 OR 3바이트)

3. NULL 과 NA 차이

4. **★Hash 알고리즘**

   - 비트코인에서도 HASH 알고리즘이 핵심적인 연산을 수행했음.

   - 비전공자가 당장 Hash를 깊게 파기에는 무리임. 간단하게 알아보자.

   - 진우님 정리한 자료 참고

   - **Hash정의 : Value to Address (값을 주소로 바꿔준다)**

     - Hf(value) = address

   - Hash 용도

     - 무결성(검증)

     - DAM(Direct Access Method): 원하는 그 위치에 직접 접근

       - 반대말: Sequential Method(ArrayList가 맨 처음 인덱스부터 찾아가는 것 등)
       - ![image](https://user-images.githubusercontent.com/63223355/81360107-f93bad80-9115-11ea-945e-054a44e91c03.png)

     - 보안

       - **단방향이다. 역해시 불가능하다.**

         - QWER1234 라는 문자를 해싱하면, c123c32c0c10c506cs0cas0 등으로 결과가 나옴. 그런데,  c123c32c0c10c506cs0cas0 값으로  QWER1234을 알아낼 수 없다.  

         - QWER1234이라는 평문을 알아내기 위해서는, 키값이 있어야 한다. 아래의 예시에서 '123'이 키값이 된다. 복호화 해서 평문을 알아낼 수 있나보다.

           - ```sql
             SELECT AES_DECRYPT(
             	UNHEX(USER_PW), '123') FROM AES;	
             // 평문이 RETURN 된다.
             ```

         - DB에는 c123c32c0c10c506cs0cas0  이라는 해싱값이 들어간다. 따라서, 네이버의 DBA가 내 비밀번호를 알 수 없다.

           - 그럼 KEY 값은 누가 알고있지?
           - ![image](https://user-images.githubusercontent.com/63223355/81885058-7b274d00-95d4-11ea-90e6-81ce1b556ffb.png)
           - ![image](https://user-images.githubusercontent.com/63223355/81885126-998d4880-95d4-11ea-9576-6e7c7e1761da.png)

   - JAVA에서 ArrayList는, 0번지부터 검색해서 n번지까지, null인지 체크하고, NULL인 경우에 그곳에 데이터를 삽입함. 느릴 수 있음.

   - Hash 충돌이란

5. PL/SQL 이란

   - PL/SQL 주말 프로젝트 예정임.

6. Pseudo column

7. OPTIMIZER 

   - DBMS Optimizer는 SQL을 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 생성해 주는 DBMS 내부의 핵심엔진이다. 사용자가 구조화된 질의언어(SQL)로 결과집합을 요구하면, 이를 생성하는데 필요한 처리경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해준다. 옵티마이저가 생성한 SQL 처리경로를 실행계획(Execution Plan)이라고 부른다.

   - DBMS 마다 Optimizer가 다를 것이다.
   - Optimizer는 OR보다 AND를 더 좋아한다.
     - 왜? 연산의 양이 줄어들기 때문이다. 
     - WHERE 절에 or이 많으면, 연산 속도가 매우 느려진다. 조심해야한다.

8. Result set(결과 집합)

9. **★★Cache(HW / SW)**

   - cpu 안에도 cache 메모리가 있다.

   - dbms 안에도 소프트웨어적인 cache가 있다.

   - ```
     CREATE SEQUENCE SCOTT.ORDER_SEQ 
     	INCREMENT BY	1
     	START WITH 		1
     	MAXVALUE 		99999999999
     	MINVALUE
     	NOCYCLE // 최대값 찍으면 죽어라. CF) CYCLE: 다시 START로 가라.
     	CACHE			30; // cache 은닉이란 뜻. 미리 30개의 숫자가 만들어진다.
     	// 잘되는 식당에 미리 음식을 30개 준비해두는 것과 같다.
     ```

10. TIER / LAYER

    - SQL server가 SELECT SYSATE FROM DUAL; 하면, DMBS는 자신의 OS에 시간을 물어보고, HW에 물어보고 다시 답변을 받는다.

- ![image](https://user-images.githubusercontent.com/63223355/81537989-07552c80-93a9-11ea-98dd-6fb30929c940.png)

11. SDLC(Software Development Life Cycle)

    - 비중(학자마다 다름)
      - 40%: 계획, 분석, 설계
      - 20%: 개발
      - 40%: 테스트
        - 테스트 시간을 충분히 확보해야 한다.
        - 시연 날에 안돌아갈 수 있다.

    1. 타당성 조사

    2. 계획(기획)

       - 범위(Scope)
         - 일정
         - 비용 

    3. **★★★요구사항 분석**

       - **★★기능**
         - 예) 글을 등록할 수 있어야 합니다.
         - 고객이 원하는 게 무엇인가(what 관점)
         - **최종 프로젝트 때는, 기능에 집중하라.**
         - 고객관점에서 봤을 때, 필요한 기능이 무엇인지 고민이 많이 필요함.
         - **분류**
           - 핵심 기능
           - 주요 기능
           - 부가 기능
       - 성능
         - 예) 클릭 후 3초 이내에 결과가 나와야 합니다.
       - 보안
         - 예) 데이터는 누출되면 안됩니다.
       - 안정성
       - 복구
       - 기타 등등

    4. 설계

       - 어떻게 구현할 것인가(how 관점)

    5. 개발

    6. 테스트

       - 잠재적 결함이 있는지 확인
       - 종류
         - 단위 테스트
           - 큰 프로젝트에서는 아주 많은 프로그램이 모여서 하나의 서비스로 구성된다.
           - 하나의 프로그램, 하나의 모듈을 테스트 하는 것
         - 통합 테스트
           - 여러 모듈을 연동해서 테스트하는 것
         - 시스템 테스트
         - 인수 테스트
         - 기타 등등..
       - 개발자와 테스터는 보통 다른 사람이다.
         - 본인이 개발한 것은 잘 감지하지 못한다.
         - 테스터만 전문적으로 하는 사람들이 있다.
         - 국내에서는 테스터가 저가의 연봉을 받지만, 해외에서는 더 대우가 좋다함.

    7. 이행(릴리즈 = 배포)

       - ![image](https://user-images.githubusercontent.com/63223355/81631952-08876780-9444-11ea-943c-da117bdfeb8e.png)

       - 환경(서버)
         - 개발 환경(서버)
         - 테스트 환경(서버)
         - 운영 환경(서버)
       - 이행(릴리즈 = 배포)
         - 개발 환경(서버) 내용을 테스트 환경(서버)으로 옮기는 것
         - 테스트 환경(서버)의 내용을 운영 환경(서버)으로 옮기는 것 

    8. 운영

    

12. OLPT VS OLAP(=DSS)

13. 엔터티란

    - 관리하고자 하는 테이블? (모델링에서는 엔터티라고 하는듯)

14. **★★★TRANSACTION** 

    - 트랜잭션에 대한 용어정리는 하셨죠?

15. 로그(LOG)

    - 사전적 의미: 통나무(예전에는 나무에 기록했잖아)
    - 기록이란 뜻.
    - 하드웨어나 소프트웨어 시스템은 항상 로그(기록)을 남긴다.

      - 몇시몇분몇초에 이런 일이 발생했다.
      - 왜 남기는가 : 사용자가 문제발생 시 참고할 수 있도록. 
    - REDO LOG FILE

      - 복구하기 위한 로그파일
      - COMMIT 때리면, REDO LOG 파일이 생기고 난 뒤에 "COMMIT 완료" 메세지를 남긴다.
      - 이 REDO LOG FILE 을 사용해서 복구할 수 있다.
    - 공통된 위치나 공통된 파일에 통합해서 로그를 관리해야 한다.
      개별 파일에 저장하면 안된다. 2000개 파일 다 뒤져볼거야?
      그래서 보통 로그 공통 모듈이 개발돼있다. 각 프로그램에서 그 모듈을 사용해서
      중앙에 로그를 모을 수 있다.

16. INDEX

    - 색인이란 뜻이다.

    - 책에서의 인덱스

      - 용도: 어떤 내용을 빨리 찾기 위해서 사용한다.
      - 구조
        - 정렬돼 있다.
        - 페이지 번호가 있다.
          - **이에 해당하는 데이터 타입이 'ROWID'**

    - DB에서의 인덱스

      - 용도: 특정 데이터를 빨리 찾기 위해서 사용한다. 대량의 데이터를 사용하려면, 반드시 INDEX가 있어야 한다.
      - 예시) 네이버에 로그인 할 때, 몇천만건의 사용자 계정 중에 내 계정을 찾아야 한다. 어떻게 그렇게 순식간에 확인하고 로그인이 되는가?

      